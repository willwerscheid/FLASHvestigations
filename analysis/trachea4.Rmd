---
title: "Pathway analysis of data from Montoro et al."
author: "Jason Willwerscheid"
date: "2/27/2019"
output: 
  workflowr::wflow_html:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Introduction

The usual way to do a pathway analysis of a gene expression dataset is to do a factor analysis and then annotate the resulting factors. Here I explore a reverse approach: instead of getting pathways from factors, I get factors from pathways.

In detail, the method is as follows. At each step, I have an EBMF decomposition $\log(Y + 1) = GC' + E$, where $Y$ is a $g \times c$ matrix of counts, $G$ is a $g \times p$ matrix whose columns give gene loadings for each of $p$ pathways, and $C$ is a $c \times p$ matrix whose columns give cell loadings for the same pathways. I use `flashier` to add a single greedy factor to the decomposition. I then extract the factor and use `SuSiE` to find a set of candidate pathways that best describe the factor. More precisely, I fit the SER model described in [Wang, Sarkar, Carbonetto, and Stephens](https://www.biorxiv.org/content/biorxiv/early/2018/12/19/501114.full.pdf), with $y$ the vector of expected gene loadings for the greedily added factor and $X$ a $g \times m$ matrix of ones and zeros indicating which genes are included in which pathways. I take the resulting 95% credible set as my set of candidate pathways. Finally, I use `flashier` to fit each of the candidate pathways to the current EBMF decomposition, fixing loadings of genes that aren't in the pathway at zero. This gives a different decomposition for each candidate pathway. I retain the pathway that gives the best EBMF objective.

The dataset analyzed here is the 3' droplet-based dataset from [Montoro et al.](https://www.nature.com/articles/s41586-018-0393-7). I remove genes that have nonzero counts in five or fewer cells. I use the set of *mus musculus* pathways from Reactome, removing pathways comprised of five or fewer genes (after removing genes that don't appear in my dataset). After preprocessing, the dataset includes counts for 6382 genes and 7193 cells, and the pathway matrix includes 824 pathways.

I analyze the full dataset first, but I'm also interested in whether a pathway analysis might be able to highlight the specific functions of ionocytes, so I subsequently analyze the subset of 26 ionocyte cells.

Click "Code" to view the code used to preprocess the data and fit the pathways.
```{r the.code, code = readLines("../code/trachea4.R"), eval = FALSE}
```

## Results: full dataset

Each pair of plots corresponds to a pathway, and results are organized according to the proportion of variance explained by each pathway. The plots on the left-hand side give cell loadings broken down by cell type (the cell type annotations are given by Montoro et al.). The plots on the right give gene loadings for all genes in the pathway, with a maximum of 50 genes displayed so that gene labels are readable. The loadings are scaled so that the maximum gene loading is equal to one. Thus, a cell loading of, say, 0.5, can be interpreted as increasing the expected count of the most highly loaded gene in the pathway by a multiplicative factor of $\exp(0.5)$.

One especially interesting thing to note is that some pathways appear in more than one factor, but when they do, they tend to be loaded on different gene sets. For example, one keratinization factor (factor 9, PVE = 0.001) is primarily loaded on Krt17, Krt5, and Krt15, and is positively loaded primarily on basal cells, while another (factor 22, PVE = 8e-04) is loaded on Krt4, Krt8, and others (with very small loadings on Krt17 and Krt5), and positively loaded primarily on club cells.

```{r the.res}
library(ggplot2)
library(gridExtra)
library(Matrix)

fl <- readRDS("~/Downloads/pw_fl50.rds")
pw.mat <- readRDS("~/Downloads/pw_mat.rds")
bm <- readRDS("~/Downloads/pw_bm.rds")

pathway.idx <- lapply(fl$fit$fix.idx[3:fl$n.factors], function(f) {
  setdiff(1:nrow(fl$fit$EF[[1]]), f)
})
pathways <- apply(pw.mat, 2, function(x) which(x == 1))
added.idx <- match(pathway.idx, pathways)
pathways.added <- names(pathways)[added.idx]

K <- fl$n.factors
gene.loadings <- fl$loadings$normalized.loadings[[1]]
cell.loadings <- fl$loadings$normalized.loadings[[2]]
scale.const <- fl$loadings$scale.constant

# Scale loadings so that the maximum gene loading is 1.
max.gene.l <- apply(gene.loadings, 2, max)
gene.loadings <- gene.loadings / rep(max.gene.l, each = nrow(gene.loadings))
cell.loadings <- cell.loadings * rep(max.gene.l * scale.const, 
                                     each = nrow(cell.loadings))

cell.names <- rownames(cell.loadings)
cell.types <- as.factor(sapply(strsplit(cell.names, "_"), `[`, 3))
# mouse <- as.factor(sapply(strsplit(cell.names, "_"), `[`, 1))

df <- data.frame(cell.loadings[, 3:K])
names(df) <- paste0("F", (3:K), ": ", pathways.added)
df$`Cell Type` <- cell.types
# df$Mouse <- mouse

plot.celltypes <- function(df, k) {
  pw <- paste0("`", names(df)[k], "`")
  the.plot <- ggplot(df, aes_string(x = "`Cell Type`", y = pw)) +
    geom_violin(aes_string(color = "`Cell Type`"),
                scale = "width", draw_quantiles = 0.5) +
    labs(x = NULL, y = "Scaled loading", color = "Cell Type") +
    theme(legend.position="none",
          axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5))
  return(the.plot)
}

plot.geneset <- function(gene.loadings, k, offset = 2, title = NULL) {
  all.loadings <- gene.loadings[, k + offset]
  pw.loadings <- data.frame(all.loadings[all.loadings > 0])
  names(pw.loadings) <- "Loading"
  if (nrow(pw.loadings) > 50) {
    cutoff <- pw.loadings$Loading[order(pw.loadings, decreasing = TRUE)[50]]
    pw.loadings <- subset(pw.loadings, Loading >= cutoff)
  }
  pw.loadings$Gene <- bm$mgi_symbol[match(rownames(pw.loadings),
                                          bm$ensembl_gene_id)]
  the.plot <- ggplot(pw.loadings, 
                     aes(x = reorder(Gene, -Loading), y = Loading)) +
    geom_bar(stat = "identity") +
    theme(axis.text.y = element_text(size = 7))
  if (!is.null(title)) {
    the.plot <- the.plot + labs(x = NULL, y = title)
  } else {
    the.plot <- the.plot + labs(x = NULL, y = "Scaled loading")
  }
  if (nrow(pw.loadings) > 30) {
    the.plot <- the.plot + 
      theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5, 
                                       size = 6)) 
  } else {
    the.plot <- the.plot + 
      theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5)) 
  }
  return(the.plot)
}

pve <- fl$pve[3:K]
k.order <- order(pve, decreasing = TRUE)
for (k in k.order) {
  plot.title <- paste0(names(df)[k], " (PVE: ", 
                       signif(pve[k], digits = 2), ")")
  plot1 <- plot.celltypes(df, k)
  plot2 <- plot.geneset(gene.loadings, k)
  grid.arrange(plot1, plot2, ncol = 2, top = plot.title)
}
```

## Results: ionocytes

I don't fit a mean factor for genes here because I'm interested in overall expression rather than how expression differs from the mean.

It's encouraging to note that the process halts after adding a relatively small number of pathways (12). Disappointingly, however, Cftr doesn't show up here. Nor does the "transferrin endocytosis and recycling" pathway, which appears above as factor 43 (PVE: 6.7e-05) and seems like it should be able to capture what Montoro et al. describe as a V-ATPase expression profile that is particular to pulmonary ionocytes.

```{r ion}
ion.fl <- readRDS("~/Downloads/ion_fl12.rds")
ion.nz.idx <- readRDS("~/Downloads/ion_nzidx.rds")

ion.pathway.idx <- lapply(ion.fl$fit$fix.idx[2:ion.fl$n.factors], function(f) {
  setdiff(1:nrow(ion.fl$fit$EF[[1]]), f)
})
pathways <- apply(pw.mat[ion.nz.idx, ], 2, function(x) which(x == 1))
added.idx <- match(ion.pathway.idx, pathways)
ion.pathways.added <- names(pathways)[added.idx]

ion.gene.l <- matrix(0, nrow = nrow(pw.mat), 
                     ncol = ncol(ion.fl$loadings$normalized.loadings[[1]]))
ion.gene.l[ion.nz.idx, ] <- ion.fl$loadings$normalized.loadings[[1]]
rownames(ion.gene.l) <- rownames(pw.mat)
max.gene.l <- apply(ion.gene.l, 2, max)
ion.gene.l <- ion.gene.l / rep(max.gene.l, each = nrow(ion.gene.l))

ion.pve <- ion.fl$pve[2:ion.fl$n.factors]
k.order <- order(ion.pve, decreasing = TRUE)
for (i in 1:(length(ion.pve) / 2)) {
  k1 <- k.order[2 * i - 1]
  k2 <- k.order[2 * i]
  title1 <- paste0(ion.pathways.added[k1], " (PVE: ", 
                   signif(ion.pve[k1], digits = 2), ")")
  title2 <- paste0(ion.pathways.added[k2], " (PVE: ", 
                   signif(ion.pve[k2], digits = 2), ")")
  plot1 <- plot.geneset(ion.gene.l, k1, offset = 1, title = title1)
  plot2 <- plot.geneset(ion.gene.l, k2, offset = 1, title = title2)
  grid.arrange(plot1, plot2, ncol = 2)
}
```

## Results summary

```{r compare}
all.pathways <- unique(c(pathways.added, ion.pathways.added))
full.idx <- lapply(all.pathways, function(pw) which(pathways.added == pw))
ion.idx <- lapply(all.pathways, function(pw) which(ion.pathways.added == pw))
full.sort <- sapply(full.idx, function(idx) {
  k.pve <- sapply(idx, function(k) pve[k])
  if (length(k.pve) == 0)
    k.pve <- 0
  max(k.pve)
})
ion.sort <- sapply(ion.idx, function(idx) {
  k.pve <- sapply(idx, function(k) ion.pve[k])
  if (length(k.pve) == 0)
    k.pve <- 0
  max(k.pve)
})
full.pve.rank <- sapply(full.idx, function(idx) {
  ranks <- sapply(idx, function(k) rank(-pve)[k])
  if (length(ranks > 0))
    ranks <- sort(ranks)
  paste(ranks, collapse = ", ")
})
ion.pve.rank <- sapply(ion.idx, function(idx) {
  ranks <- sapply(idx, function(k) rank(-ion.pve)[k])
  if (length(ranks > 0))
    ranks <- sort(ranks)
  paste(ranks, collapse = ", ")
})
df <- data.frame(pathway = all.pathways,
                 ion.rank = ion.pve.rank,
                 full.rank = full.pve.rank,
                 sort.order = 1000 * ion.sort + full.sort)
df <- df[order(df$sort.order, decreasing = TRUE), ]
df$sort.order <- NULL
rownames(df) <- NULL
knitr::kable(df, 
             col.names = c("Pathway", "Rank (ionocytes)", "Rank (all cells)"))
```
