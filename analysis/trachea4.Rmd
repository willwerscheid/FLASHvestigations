---
title: "Pathway analysis of data from Montoro et al."
author: "Jason Willwerscheid"
date: "2/27/2019"
output: 
  workflowr::wflow_html:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Introduction

The usual way to do a pathway analysis of a gene expression dataset is to do a factor analysis and then annotate the resulting factors. Here I explore a reverse approach: instead of getting pathways from factors, I get factors from pathways.

In detail, the method is as follows. At each step, I have an EBMF decomposition $\log(Y + 1) = GC' + E$, where $Y$ is a $g \times c$ matrix of counts, $G$ is a $g \times p$ matrix whose columns give gene loadings for each of $p$ pathways, and $C$ is a $c \times p$ matrix whose columns give cell loadings for the same pathways. I use `flashier` to add a single greedy factor to the decomposition. I then extract the factor and use `SuSiE` to find a set of candidate pathways that best describe the factor. More precisely, I fit the SER model described in [Wang, Sarkar, Carbonetto, and Stephens](https://www.biorxiv.org/content/biorxiv/early/2018/12/19/501114.full.pdf), with $y$ the vector of expected gene loadings for the greedily added factor and $X$ a $g \times m$ matrix of ones and zeros indicating which genes are included in which pathways. I take the resulting 95% credible set as my set of candidate pathways. Finally, I use `flashier` to fit each of the candidate pathways to the current EBMF decomposition, fixing loadings of genes that aren't in the pathway at zero. This gives a different decomposition for each candidate pathway. I retain the pathway that gives the best EBMF objective.

The dataset analyzed here is the 3' droplet-based dataset from [Montoro et al.](https://www.nature.com/articles/s41586-018-0393-7). I remove genes that have nonzero counts in five or fewer cells. I use the set of *mus musculus* pathways from Reactome, removing pathways comprised of five or fewer genes (after removing genes that don't appear in my dataset). After preprocessing, the dataset includes counts for 6382 genes and 7193 cells, and the pathway matrix includes 824 pathways.

I analyze the full dataset first, but I'm also interested in whether a pathway analysis might be able to highlight the specific functions of ionocytes, so I subsequently analyze the subset of 26 ionocyte cells.

Click "Code" to view the code used to preprocess the data and fit the pathways.
```{r the.code, code = readLines("../code/trachea4.R"), eval = FALSE}
```

## Results: full dataset

I fit 40 pathways using the method outlined above. Each pair of plots corresponds to a pathway, and results are organized according to the proportion of variance explained by each pathway. The plots on the left-hand side give cell loadings broken down by cell type (the cell type annotations are given by Montoro et al.). The plots on the right give gene loadings for all genes in the pathway, with a maximum of 50 genes displayed so that gene labels are readable. The loadings are scaled so that the maximum gene loading is equal to one. Thus, a cell loading of, say, 0.5, can be interpreted as increasing the expected count of the most highly loaded gene in the pathway by a multiplicative factor of $\exp(0.5)$.

One especially interesting thing to note is that some pathways appear in more than one factor, but when they do, they tend to be loaded on different gene sets. For example, one neutrophil degranulation factor (factor 13, PVE = 0.0063) is most heavily loaded on Ltf, and is positively loaded primarily on goblet and club cells, while another (factor 36, PVE = 0.0016) is most heavily loaded on Lgals3 and positively loaded primarily on ciliated cells.

```{r the.res}
library(ggplot2)
library(gridExtra)
library(Matrix)

fl <- readRDS("~/Downloads/pw_fl.rds")
pw.mat <- readRDS("~/Downloads/pw_mat.rds")
bm <- readRDS("~/Downloads/pw_bm.rds")

pathway.idx <- lapply(fl$fit$fix.idx[3:fl$n.factors], function(f) {
  setdiff(1:nrow(fl$fit$EF[[1]]), f)
})
pathways <- apply(pw.mat, 2, function(x) which(x == 1))
added.idx <- match(pathway.idx, pathways)
pathways.added <- names(pathways)[added.idx]

gene.loadings <- fl$loadings$normalized.loadings[[1]]
cell.loadings <- fl$loadings$normalized.loadings[[2]]
scale.const <- fl$loadings$scale.constant

# Scale loadings so that the maximum gene loading is 1.
max.gene.l <- apply(gene.loadings, 2, max)
gene.loadings <- gene.loadings / rep(max.gene.l, each = nrow(gene.loadings))
cell.loadings <- cell.loadings * rep(max.gene.l * scale.const, 
                                     each = nrow(cell.loadings))

cell.names <- rownames(cell.loadings)
cell.types <- as.factor(sapply(strsplit(cell.names, "_"), `[`, 3))
# mouse <- as.factor(sapply(strsplit(cell.names, "_"), `[`, 1))

K <- fl$n.factors
df <- data.frame(cell.loadings[, 3:K])
names(df) <- paste0("F", (3:K), ": ", pathways.added)
df$`Cell Type` <- cell.types
# df$Mouse <- mouse

plot.celltypes <- function(df, k) {
  pw <- paste0("`", names(df)[k], "`")
  the.plot <- ggplot(df, aes_string(x = "`Cell Type`", y = pw)) +
    geom_violin(aes_string(color = "`Cell Type`"),
                scale = "width", draw_quantiles = 0.5) +
    labs(x = NULL, y = "Scaled loading", color = "Cell Type") +
    theme(legend.position="none",
          axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5))
  return(the.plot)
}

plot.geneset <- function(gene.loadings, k, offset = 0) {
  all.loadings <- gene.loadings[, k + offset]
  pw.loadings <- data.frame(all.loadings[all.loadings > 0])
  names(pw.loadings) <- "Loading"
  if (nrow(pw.loadings) > 50) {
    cutoff <- pw.loadings$Loading[order(pw.loadings, decreasing = TRUE)[50]]
    pw.loadings <- subset(pw.loadings, Loading >= cutoff)
  }
  pw.loadings$Gene <- bm$mgi_symbol[match(rownames(pw.loadings),
                                          bm$ensembl_gene_id)]
  the.plot <- ggplot(pw.loadings, 
                     aes(x = reorder(Gene, -Loading), y = Loading)) +
    geom_bar(stat = "identity") +
    theme(axis.text.y = element_text(size = 7)) + 
    labs(x = NULL, y = "Scaled loading")
  if (nrow(pw.loadings) > 30) {
    the.plot <- the.plot + 
      theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5, 
                                       size = 6)) 
  } else {
    the.plot <- the.plot + 
      theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5)) 
  }
  return(the.plot)
}

pve <- fl$pve[3:K]
k.order <- order(pve, decreasing = TRUE)
for (k in k.order) {
  plot.title <- paste0(names(df)[k], " (PVE: ", 
                       signif(pve[k], digits = 2), ")")
  plot1 <- plot.celltypes(df, k)
  plot2 <- plot.geneset(gene.loadings, k, offset = 2)
  grid.arrange(plot1, plot2, ncol = 2, top = plot.title)
}
```

## Results: ionocytes

To analyze the subset of ionocytes, I residualize out the mean factors from the above fit (the idea is to see how ionocyte expression differs from mean epithelial expression). I again fit 40 factors.

The approach doesn't give me what I want. I've only been able to find factors that say something about what ionocytes don't express, not what they do (all cell loadings are negative). It might be simply a matter of adding more factors, but most likely the overall approach needs to be rethought.

Most disappointingly, Cftr doesn't show up here. It's worth considering why. In the full dataset (7193 cells), there is 1 cell (an ionocyte) with 6 Cftr transcripts, 1 with 3 transcripts, 5 with 2, and 12 with 1. Of the 26 ionocytes, 17 don't have any Cftr transcripts, but of the 19 total cells that have any Cftr transcripts, 9 are ionocytes. Further, I've set standard errors as
$$ S_{ij} = \frac{\sqrt{Y_{ij}}}{Y_{ij} + 1} $$
with $S_{ij} = 1/2$ when $Y_{ij} = 0$, so when the clustering is not given in advance, $Y_{ij} = \log(Y_{ij} + 1) = 0$ does not look much different from $Y_{ij} = 1$ (i.e., $\log(Y_{ij} + 1) \approx 0.69$). ($Y_{ij} = 2$ is also only slightly more than one standard error away from zero.) So the way I've transformed the data and set standard errors will not have much power to detect changes in expression when all counts are low.

```{r ion}
ion.fl <- readRDS("~/Downloads/ion_fl40.rds")
ion.nz.idx <- readRDS("~/Downloads/ion_subset.rds")$rows

ion.pathway.idx <- lapply(ion.fl$fit$fix.idx, function(f) {
  setdiff(1:nrow(ion.fl$fit$EF[[1]]), f)
})
pathways <- apply(pw.mat[ion.nz.idx, ], 2, function(x) which(x == 1))
added.idx <- match(ion.pathway.idx, pathways)
ion.pathways.added <- names(pathways)[added.idx]

ion.gene.l <- matrix(0, nrow = nrow(pw.mat), 
                     ncol = ncol(ion.fl$loadings$normalized.loadings[[1]]))
ion.gene.l[ion.nz.idx, ] <- ion.fl$loadings$normalized.loadings[[1]]
rownames(ion.gene.l) <- rownames(pw.mat)
ion.cell.l <- ion.fl$loadings$normalized.loadings[[2]]
ion.scale <- ion.fl$loadings$scale.constant

max.gene.l <- apply(ion.gene.l, 2, max)
ion.gene.l <- ion.gene.l / rep(max.gene.l, each = nrow(ion.gene.l))
ion.cell.l <- ion.cell.l * rep(max.gene.l * ion.scale, each = nrow(ion.cell.l))
  
plot.cellloadings <- function(cell.loadings, k) {
  df <- data.frame(cell.loadings[, k])
  names(df) <- "Loading"
  df$Cell <- 1:nrow(cell.loadings)
  the.plot <- ggplot(df, aes(x = reorder(Cell, -Loading), y = Loading)) +
    geom_bar(stat = "identity") +
    labs(x = "Cells", y = "Scaled Loading") +
    theme(axis.text.x = element_blank())
  return(the.plot)
}

ion.pve <- ion.fl$pve
k.order <- order(ion.pve, decreasing = TRUE)
for (k in k.order) {
  plot.title <- paste0(ion.pathways.added[k], " (PVE: ", 
                       signif(ion.pve[k], digits = 2), ")")
  plot1 <- plot.cellloadings(ion.cell.l, k)
  plot2 <- plot.geneset(ion.gene.l, k)
  grid.arrange(plot1, plot2, ncol = 2, top = plot.title)
}
```

## Results summary

```{r compare}
all.pathways <- unique(c(pathways.added, ion.pathways.added))
full.idx <- lapply(all.pathways, function(pw) which(pathways.added == pw))
ion.idx <- lapply(all.pathways, function(pw) which(ion.pathways.added == pw))
full.sort <- sapply(full.idx, function(idx) {
  k.pve <- sapply(idx, function(k) pve[k])
  if (length(k.pve) == 0)
    k.pve <- 0
  max(k.pve)
})
ion.sort <- sapply(ion.idx, function(idx) {
  k.pve <- sapply(idx, function(k) ion.pve[k])
  if (length(k.pve) == 0)
    k.pve <- 0
  max(k.pve)
})
full.pve.rank <- sapply(full.idx, function(idx) {
  ranks <- sapply(idx, function(k) rank(-pve)[k])
  if (length(ranks > 0))
    ranks <- sort(ranks)
  paste(ranks, collapse = ", ")
})
ion.pve.rank <- sapply(ion.idx, function(idx) {
  ranks <- sapply(idx, function(k) rank(-ion.pve)[k])
  if (length(ranks > 0))
    ranks <- sort(ranks)
  paste(ranks, collapse = ", ")
})
df <- data.frame(pathway = all.pathways,
                 ion.rank = ion.pve.rank,
                 full.rank = full.pve.rank,
                 sort.order = 1000 * ion.sort + full.sort)
df <- df[order(df$sort.order, decreasing = TRUE), ]
df$sort.order <- NULL
rownames(df) <- NULL
knitr::kable(df, col.names = c("Pathway", 
                               "Rank (ionocytes)", 
                               "Rank (all cells)"))
```
