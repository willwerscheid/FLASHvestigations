<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Jason Willwerscheid" />


<title>Matrix factorization of count data</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">FLASHvestigations</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/willwerscheid/FLASHvestigations">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<!-- Add a small amount of space between sections. -->
<style type="text/css">
div.section {
  padding-top: 12px;
}
</style>

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Matrix factorization of count data</h1>
<h4 class="author"><em>Jason Willwerscheid</em></h4>
<h4 class="date"><em>9/20/2018</em></h4>

</div>


<p><strong>Last updated:</strong> 2018-09-23</p>
<strong>workflowr checks:</strong> <small>(Click a bullet for more information)</small>
<ul>
<li>
<p><details> <summary> <strong style="color:blue;">✔</strong> <strong>R Markdown file:</strong> up-to-date </summary></p>
<p>Great! Since the R Markdown file has been committed to the Git repository, you know the exact version of the code that produced these results.</p>
</details>
</li>
<li>
<p><details> <summary> <strong style="color:blue;">✔</strong> <strong>Environment:</strong> empty </summary></p>
<p>Great job! The global environment was empty. Objects defined in the global environment can affect the analysis in your R Markdown file in unknown ways. For reproduciblity it’s best to always run the code in an empty environment.</p>
</details>
</li>
<li>
<p><details> <summary> <strong style="color:blue;">✔</strong> <strong>Seed:</strong> <code>set.seed(20180714)</code> </summary></p>
<p>The command <code>set.seed(20180714)</code> was run prior to running the code in the R Markdown file. Setting a seed ensures that any results that rely on randomness, e.g. subsampling or permutations, are reproducible.</p>
</details>
</li>
<li>
<p><details> <summary> <strong style="color:blue;">✔</strong> <strong>Session information:</strong> recorded </summary></p>
<p>Great job! Recording the operating system, R version, and package versions is critical for reproducibility.</p>
</details>
</li>
<li>
<p><details> <summary> <strong style="color:blue;">✔</strong> <strong>Repository version:</strong> <a href="https://github.com/willwerscheid/FLASHvestigations/tree/de34f1450a118a4af4e16787ebd543860936058b" target="_blank">de34f14</a> </summary></p>
Great! You are using Git for version control. Tracking code development and connecting the code version to the results is critical for reproducibility. The version displayed above was the version of the Git repository at the time these results were generated. <br><br> Note that you need to be careful to ensure that all relevant files for the analysis have been committed to Git prior to generating the results (you can use <code>wflow_publish</code> or <code>wflow_git_commit</code>). workflowr only checks the R Markdown file, but you know if there are other scripts or data files that it depends on. Below is the status of the Git repository when the results were generated:
<pre><code>
Ignored files:
    Ignored:    .DS_Store
    Ignored:    .Rhistory
    Ignored:    .Rproj.user/
    Ignored:    docs/.DS_Store
    Ignored:    docs/figure/.DS_Store

Untracked files:
    Untracked:  analysis/binary_data.Rmd
    Untracked:  data/greedy19.rds

</code></pre>
Note that any generated files, e.g. HTML, png, CSS, etc., are not included in this status report because it is ok for generated content to have uncommitted changes. </details>
</li>
</ul>
<details> <summary> <small><strong>Expand here to see past versions:</strong></small> </summary>
<ul>
<table style="border-collapse:separate; border-spacing:5px;">
<thead>
<tr>
<th style="text-align:left;">
File
</th>
<th style="text-align:left;">
Version
</th>
<th style="text-align:left;">
Author
</th>
<th style="text-align:left;">
Date
</th>
<th style="text-align:left;">
Message
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Rmd
</td>
<td style="text-align:left;">
<a href="https://github.com/willwerscheid/FLASHvestigations/blob/de34f1450a118a4af4e16787ebd543860936058b/analysis/count_data.Rmd" target="_blank">de34f14</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-23
</td>
<td style="text-align:left;">
wflow_publish(“analysis/count_data.Rmd”)
</td>
</tr>
<tr>
<td style="text-align:left;">
html
</td>
<td style="text-align:left;">
<a href="https://cdn.rawgit.com/willwerscheid/FLASHvestigations/410eb80ebb5d5f78bd8705794330bc8a11a0c7f8/docs/count_data.html" target="_blank">410eb80</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-22
</td>
<td style="text-align:left;">
Build site.
</td>
</tr>
<tr>
<td style="text-align:left;">
Rmd
</td>
<td style="text-align:left;">
<a href="https://github.com/willwerscheid/FLASHvestigations/blob/5bfea2c78d7ad53a3ec1d3e61804a09392e21d54/analysis/count_data.Rmd" target="_blank">5bfea2c</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-22
</td>
<td style="text-align:left;">
wflow_publish(“analysis/count_data.Rmd”)
</td>
</tr>
<tr>
<td style="text-align:left;">
html
</td>
<td style="text-align:left;">
<a href="https://cdn.rawgit.com/willwerscheid/FLASHvestigations/8b731598d9b702cdb6b353a34e1db6d688dca2ae/docs/count_data.html" target="_blank">8b73159</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-21
</td>
<td style="text-align:left;">
Build site.
</td>
</tr>
<tr>
<td style="text-align:left;">
Rmd
</td>
<td style="text-align:left;">
<a href="https://github.com/willwerscheid/FLASHvestigations/blob/884f8fa89b22b487814c1e2d0e77120325ac12dd/analysis/count_data.Rmd" target="_blank">884f8fa</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-21
</td>
<td style="text-align:left;">
wflow_publish(“analysis/count_data.Rmd”)
</td>
</tr>
</tbody>
</table>
</ul>
<p></details></p>
<hr />
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>In a <a href="nonnegative.html">previous analysis</a>, I used FLASH to obtain a nonnegative matrix factorization of the GTEx donation matrix. There, I proceeded as if the observations were normally distributed. Here, I explore a more sophisticated approach to count data.</p>
</div>
<div id="model" class="section level2">
<h2>Model</h2>
<p>I assume that the data is generated as <span class="math display">\[ Y \sim \text{Poisson}(\mu), \]</span> where <span class="math display">\[ \log(\mu) = LF&#39; = \sum_{k = 1}^K l_k f_k&#39;, \]</span> with an ASH prior on the entries of each loading <span class="math inline">\(l_k\)</span> and each factor <span class="math inline">\(f_k\)</span> <span class="math display">\[ l_k \sim g_{l_k},\ f_k \sim g_{f_k}. \]</span></p>
<p>To account for overdispersion, one can also fit the model <span class="math display">\[ \log(\mu) = LF&#39; + E, \]</span> where the entries of <span class="math inline">\(E\)</span> are i.i.d. <span class="math inline">\(N(0, \sigma^2)\)</span> and <span class="math inline">\(\sigma^2\)</span> is to be estimated.</p>
</div>
<div id="idea" class="section level2">
<h2>Idea</h2>
<p>The general idea is outlined by Matthew Stephens <a href="https://stephens999.github.io/misc/wSVD.html#introduction">here</a>.</p>
<p>To apply the idea to FLASH, I replace the part of the objective function that comes from the residuals with the Poisson log likelihood <span class="math display">\[ \ell(\mu) = \sum_{i, j} -\mu_{ij} + Y_{ij} \log \mu_{ij}. \]</span> Set <span class="math inline">\(\eta_{ij} = \log \mu_{ij}\)</span> so that <span class="math display">\[ \ell(\eta) = \sum_{i, j} -e^{\eta_{ij}} + Y_{ij} \eta_{ij}. \]</span></p>
<p>Now do a second-order Taylor expansion of <span class="math inline">\(\ell(\eta)\)</span> around some (for now, arbitrary) point <span class="math inline">\(\eta^\star\)</span>: <span class="math display">\[ \ell(\eta) = \ell(\eta^\star) + (\eta - \eta^\star) \ell&#39;(\eta^\star) + \frac{(\eta - \eta^\star)^2}{2} \ell&#39;&#39;(\eta^\star). \]</span></p>
<p>Up to a constant, this is the log likelihood for the distribution <span class="math display">\[ \eta \sim \text{Normal}\left(\eta^\star - \frac{\ell&#39;(\eta^\star)}{\ell&#39;&#39;(\eta^\star)}, -\frac{1}{\ell&#39;&#39;(\eta^\star)}\right). \]</span></p>
<p>Thus, given a good enough choice of <span class="math inline">\(\eta^\star\)</span>, we should be able to run FLASH on the “pseudo-data” <span class="math display">\[ X = \eta^\star - \frac{\ell&#39;(\eta^\star)}{\ell&#39;&#39;(\eta^\star)} \]</span> with “standard errors” <span class="math display">\[ S = \frac{1}{\sqrt{-\ell&#39;&#39;(\eta^\star)}}. \]</span></p>
<p>I calculate <span class="math display">\[ \begin{aligned}
\ell&#39;(\eta^\star) &amp;= \sum_{i, j} -e^{\eta^\star_{ij}} + Y_{ij} \\
&amp;= \sum_{i, j} Y_{ij} - \mu^\star_{ij} \\
\ell&#39;&#39;(\eta^\star) &amp;= \sum_{i, j} -e^{\eta^\star_{ij}} \\
&amp;= \sum_{i, j} -\mu^\star_{ij}, 
\end{aligned} \]</span> which yields pseudo-data <span class="math display">\[ X = \log(\mu^\star) + \frac{Y - \mu^\star}{\mu^\star} \]</span> with standard errors <span class="math display">\[ S = \frac{1}{\sqrt{\mu^\star}}.\]</span></p>
<p>To fit the model <span class="math inline">\(\log(\mu) = LF&#39;\)</span>, one fixes the standard errors by setting <code>var_type = &quot;zero&quot;</code>. To fit the overdispersed model <span class="math inline">\(\log(\mu) = LF&#39; + E\)</span>, one sets <code>var_type = &quot;constant&quot;</code> so that each observation has variance <span class="math inline">\(S_{ij}^2 + \sigma^2\)</span>.</p>
<p>Now, the crux in all of this is to choose an <span class="math inline">\(\eta^\star\)</span> that is as close as possible to the <span class="math inline">\(\eta\)</span> that minimizes the objective function. An iterative procedure suggests itself whereby one fits FLASH to the pseudo-data generated by a given choice of <span class="math inline">\(\eta^\star\)</span>, then updates <span class="math inline">\(\eta^\star\)</span> to be the posterior mean given by the FLASH fit, then fits FLASH to the pseudo-data generated by the new <span class="math inline">\(\eta^\star\)</span>, and so on until convergence.</p>
</div>
<div id="objective-function" class="section level2">
<h2>Objective function</h2>
<p>I noted above that the objective I am interested in is approximately the same as the FLASH objective “up to a constant.” This constant, however, can depend on the choice of <span class="math inline">\(\eta^\star\)</span>. To monitor the progress of the fit, it will be useful to be able to calculate its (approximate) value.</p>
<p>The log likelihood I am interested in is <span class="math display">\[ \ell(\eta) \approx \ell(\eta^\star) + (\eta - \eta^\star) \ell&#39;(\eta^\star) + \frac{(\eta - \eta^\star)^2}{2} \ell&#39;&#39;(\eta^\star). \]</span></p>
<p>The log likelihood of the normal approximation is <span class="math display">\[ \begin{aligned}
\ell_N(\eta) &amp;= -\frac{1}{2} \log \left( \frac{2 \pi}{-\ell&#39;&#39;(\eta^\star)} \right) 
+ \frac{\ell&#39;&#39;(\eta^\star)}{2} \left( \eta - \eta^\star + \frac{\ell&#39;(\eta^\star)}{\ell&#39;&#39;(\eta^\star)} \right)^2 \\
&amp;= -\frac{1}{2} \log \left( \frac{2 \pi}{-\ell&#39;&#39;(\eta^\star)} \right) 
+ \frac{(\ell&#39;(\eta^\star))^2}{2 \ell&#39;&#39;(\eta^\star)}
+ (\eta - \eta^\star) \ell&#39;(\eta^\star) 
+ \frac{(\eta - \eta^\star)^2}{2} \ell&#39;&#39;(\eta^\star)
\end{aligned} \]</span> which gives <span class="math display">\[ \ell(\eta) 
\approx \ell_N(\eta) + \ell(\eta^\star)
+ \frac{1}{2} \log \left( \frac{2 \pi}{-\ell&#39;&#39;(\eta^\star)} \right) 
- \frac{(\ell&#39;(\eta^\star))^2}{2 \ell&#39;&#39;(\eta^\star)}.\]</span></p>
<p>In the Poisson case studied here, the objective can thus be calculated as the FLASH objective plus <span class="math display">\[ \sum_{i, j} -\mu^\star_{ij} + Y_{ij} \log \mu^\star_{ij} 
+ \frac{1}{2}\log \left( \frac{2 \pi}{\mu^\star_{ij}} \right)
+ \frac{(Y_{ij} - \mu^\star_{ij})^2}{2\mu^\star_{ij}}.\]</span></p>
</div>
<div id="code-and-example" class="section level2">
<h2>Code and example</h2>
<p>First I load the data:</p>
<pre class="r"><code>devtools::load_all(&quot;~/GitHub/flashr&quot;)
#&gt; Loading flashr
devtools::load_all(&quot;~/GitHub/ebnm&quot;)
#&gt; Loading ebnm

raw &lt;- read.csv(&quot;https://storage.googleapis.com/gtex_analysis_v6/annotations/GTEx_Data_V6_Annotations_SampleAttributesDS.txt&quot;,
                header=TRUE, sep=&#39;\t&#39;)

data &lt;- raw[, c(&quot;SAMPID&quot;, &quot;SMTSD&quot;)] # sample ID, tissue type
# Extract donor ID:
tmp &lt;- strsplit(as.character(data$SAMPID), &quot;-&quot;)
data$SAMPID &lt;- as.factor(sapply(tmp, function(x) {x[[2]]})) 
names(data) &lt;- c(&quot;DonorID&quot;, &quot;TissueType&quot;)

data &lt;- suppressMessages(reshape2::acast(data, TissueType ~ DonorID))

missing.tissues &lt;- c(1, 8, 9, 20, 21, 24, 26, 27, 33, 36, 39)
data &lt;- data[-missing.tissues, ]

# Drop columns with no samples:
data = data[, colSums(data) &gt; 0]

gtex.colors &lt;- read.table(&quot;https://github.com/stephenslab/gtexresults/blob/master/data/GTExColors.txt?raw=TRUE&quot;,
                          sep = &#39;\t&#39;, comment.char = &#39;&#39;)
gtex.colors &lt;- gtex.colors[-c(7, 8, 19, 20, 24, 25, 31, 34, 37), 2]
gtex.colors &lt;- as.character(gtex.colors)</code></pre>
<p>I will use the following functions to fit the model:</p>
<pre class="r"><code># Computing objective (ELBO) -------------------------------------------

calc_obj &lt;- function(fl, the_data, mu) {
  return(fl$objective + 
           sum(-mu + the_data * log(mu) + 
                 0.5 * (log(2 * pi / mu) + (the_data - mu)^2 / mu)))
}

# Calculating pseudo-data ----------------------------------------------

calc_X &lt;- function(the_data, mu) {
  return(log(mu) + (the_data - mu) / mu)
}

calc_S &lt;- function(the_data, mu) {
  return(1 / sqrt(mu))
}

set_pseudodata &lt;- function(the_data, mu) {
  return(flash_set_data(calc_X(the_data, mu), S = calc_S(the_data, mu)))
}

# Setting FLASH parameters ---------------------------------------------

# Initialization function for nonnegative loadings 
#   (but arbitrary factors):
my_init_fn &lt;- function(Y, K = 1) {
  ret = udv_svd(Y, K)
  sum_pos = sum(ret$u[ret$u &gt; 0]^2)
  sum_neg = sum(ret$u[ret$u &lt; 0]^2)
  if (sum_neg &gt; sum_pos) {
    return(list(u = -ret$u, d = ret$d, v = -ret$v))
  } else
    return(ret)
}

get_init_fn &lt;- function(nonnegative = FALSE) {
  if (nonnegative) {
    return(&quot;my_init_fn&quot;)
  } else {
    return(&quot;udv_svd&quot;)
  }
}

get_ebnm_fn &lt;- function(nonnegative = FALSE) {
  if (nonnegative) {
    return(list(l = &quot;ebnm_ash&quot;, f = &quot;ebnm_pn&quot;))
  } else {
    return(list(l = &quot;ebnm_pn&quot;, f = &quot;ebnm_pn&quot;))
  }
}

get_ebnm_param &lt;- function(nonnegative = FALSE) {
  if (nonnegative) {
    return(list(l = list(mixcompdist = &quot;+uniform&quot;),
                f = list(warmstart = TRUE)))
  } else {
    return(list(l = list(warmstart = TRUE),
                f = list(warmstart = TRUE)))
  }
}

# Initializing mu and running FLASH ------------------------------------

init_mu &lt;- function(the_data, f_init) {
  if (is.null(f_init)) {
    return(matrix(colMeans(the_data),
                  nrow = nrow(the_data), ncol = ncol(the_data),
                  byrow = TRUE))
  } else {
    return(exp(f_init$fitted_values))
  }
}

greedy_iter &lt;- function(the_data, mu, f_init, niter, 
                        nonnegative = FALSE, var_type = &quot;zero&quot;) {
  suppressWarnings(
    flash_greedy_workhorse(set_pseudodata(the_data, mu),
                           Kmax = 1,
                           f_init = f_init,
                           var_type = var_type,
                           ebnm_fn = get_ebnm_fn(nonnegative),
                           ebnm_param = get_ebnm_param(nonnegative),
                           init_fn = get_init_fn(nonnegative),
                           verbose_output = &quot;&quot;,
                           nullcheck = FALSE,
                           maxiter = niter)
  )
}

backfit_iter &lt;- function(the_data, mu, f_init, kset, niter, 
                         nonnegative = FALSE, var_type = &quot;zero&quot;) {
  suppressWarnings(
    flash_backfit_workhorse(set_pseudodata(the_data, mu),
                            kset = kset,
                            f_init = f_init,
                            var_type = var_type,
                            ebnm_fn = get_ebnm_fn(nonnegative),
                            ebnm_param = get_ebnm_param(nonnegative),
                            verbose_output = &quot;&quot;,
                            nullcheck = FALSE,
                            maxiter = niter)
  )
}

run_one_fit &lt;- function(the_data, f_init, greedy, maxiter = 200,
                        n_subiter = 200, nonnegative = FALSE, 
                        var_type = &quot;zero&quot;, 
                        verbose = TRUE, tol = .01) {
  mu &lt;- init_mu(the_data, f_init)

  if (greedy) {
    fl &lt;- greedy_iter(the_data, mu, f_init, n_subiter, 
                      nonnegative, var_type)
    kset &lt;- ncol(fl$fit$EL) # Only &quot;backfit&quot; the greedily added factor
    mu &lt;- exp(fl$fitted_values)
  } else {
    fl &lt;- f_init
    kset &lt;- 1:ncol(fl$fit$EL) # Backfit all factor/loadings
  }

  # The objective can get stuck oscillating between two values, so we
  #   need to track the last two values attained:
  old_old_obj &lt;- -Inf
  old_obj &lt;- -Inf
  diff &lt;- Inf
  iter &lt;- 0
  while (diff &gt; tol &amp;&amp; iter &lt; maxiter) {
    iter &lt;- iter + 1
    fl &lt;- backfit_iter(the_data, mu, fl, kset, n_subiter, 
                       nonnegative, var_type)

    fl$objective &lt;- calc_obj(fl, the_data, mu)
    diff &lt;- min(abs(fl$objective - old_obj), 
                abs(fl$objective - old_old_obj))

    old_old_obj &lt;- old_obj
    old_obj &lt;- fl$objective
    
    mu &lt;- exp(fl$fitted_values)

    if (verbose) {
      message(&quot;Iteration &quot;, iter, &quot;: &quot;, fl$objective)
    }
  }
  return(fl)
}</code></pre>
<p>I greedily add a factor by initializing <span class="math inline">\(\mu^\star\)</span> to the column means of the data, then alternating between running FLASH on the “pseudo-data” corresponding to the current <span class="math inline">\(\mu^\star\)</span> and updating <span class="math inline">\(\mu^\star\)</span> to be the posterior mean of the current FLASH fit:</p>
<pre class="r"><code>fl &lt;- run_one_fit(data, f_init = NULL, greedy = TRUE, var_type = &quot;zero&quot;)
#&gt; Iteration 1: -1260894162288.67
#&gt; Iteration 2: -463857047403.473
#&gt; Iteration 3: -170643479882.396
#&gt; Iteration 4: -62776237234.5249
#&gt; Iteration 5: -23094096826.1362
#&gt; Iteration 6: -8495853575.88706
#&gt; Iteration 7: -3125460273.93256
#&gt; Iteration 8: -1149803165.46822
#&gt; Iteration 9: -422999642.579889
#&gt; Iteration 10: -155623640.841263
#&gt; Iteration 11: -57261563.5405482
#&gt; Iteration 12: -21076221.7751938
#&gt; Iteration 13: -7764412.09339289
#&gt; Iteration 14: -2867291.88319422
#&gt; Iteration 15: -1065747.76233328
#&gt; Iteration 16: -402996.603236368
#&gt; Iteration 17: -159177.534036103
#&gt; Iteration 18: -69469.4385910787
#&gt; Iteration 19: -36455.0120088927
#&gt; Iteration 20: -24297.6435128183
#&gt; Iteration 21: -19817.4081220096
#&gt; Iteration 22: -18173.1057830217
#&gt; Iteration 23: -17596.0378156151
#&gt; Iteration 24: -17430.9092946137
#&gt; Iteration 25: -17390.3239093269
#&gt; Iteration 26: -17383.7304196358
#&gt; Iteration 27: -17383.2088444385
#&gt; Iteration 28: -17383.2107211963</code></pre>
<p>Although the initial estimate of <span class="math inline">\(\mu^\star\)</span> is terrible, the objective seems to eventually converge.</p>
<p>I continue to greedily add factors in the same way:</p>
<pre class="r"><code>fl &lt;- run_one_fit(data, f_init = fl, greedy = TRUE, var_type = &quot;zero&quot;)
#&gt; Iteration 1: -16636.2584752266
#&gt; Iteration 2: -16585.7129718596
#&gt; Iteration 3: -16580.7737927336
#&gt; Iteration 4: -16580.7926674945
#&gt; Iteration 5: -16580.8273337167
#&gt; Iteration 6: -16580.8412000009
#&gt; Iteration 7: -16580.8467232789
fl &lt;- run_one_fit(data, f_init = fl, greedy = TRUE, var_type = &quot;zero&quot;)
#&gt; Iteration 1: -16580.848902757
#&gt; Iteration 2: -16580.8497609812</code></pre>
<p>Since the third factor no longer offers any improvement, I stop adding factors and backfit:</p>
<pre class="r"><code>fl &lt;- run_one_fit(data, f_init = fl, greedy = FALSE, var_type = &quot;zero&quot;)
#&gt; Iteration 1: -16409.37888059
#&gt; Iteration 2: -16181.1318746537
#&gt; Iteration 3: -16095.2934227321
#&gt; Iteration 4: -16042.4790068713
#&gt; Iteration 5: -16018.4893710094
#&gt; Iteration 6: -16008.4462444063
#&gt; Iteration 7: -16004.7357433436
#&gt; Iteration 8: -16003.5327873971
#&gt; Iteration 9: -16003.1145834296
#&gt; Iteration 10: -16002.9179080359
#&gt; Iteration 11: -16002.8323975208
#&gt; Iteration 12: -16002.8006825269
#&gt; Iteration 13: -16002.7908969895</code></pre>
<p>I now examine the resulting loadings. One loading primarily represents correlations among brain (and pituitary) tissues; the other represents correlations among the remaining tissues.</p>
<pre class="r"><code>plot(fl, plot_loadings = TRUE, loading_colors = gtex.colors,
     loading_legend_size = 3, plot_scree = FALSE)</code></pre>
<p><img src="figure/count_data.Rmd/ex4-1.png" width="672" style="display: block; margin: auto;" /></p>
<details> <summary><em>Expand here to see past versions of ex4-1.png:</em></summary>
<table style="border-collapse:separate; border-spacing:5px;">
<thead>
<tr>
<th style="text-align:left;">
Version
</th>
<th style="text-align:left;">
Author
</th>
<th style="text-align:left;">
Date
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<a href="https://github.com/willwerscheid/FLASHvestigations/blob/410eb80ebb5d5f78bd8705794330bc8a11a0c7f8/docs/figure/count_data.Rmd/ex4-1.png" target="_blank">410eb80</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-22
</td>
</tr>
<tr>
<td style="text-align:left;">
<a href="https://github.com/willwerscheid/FLASHvestigations/blob/8b731598d9b702cdb6b353a34e1db6d688dca2ae/docs/figure/count_data.Rmd/ex4-1.png" target="_blank">8b73159</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-21
</td>
</tr>
</tbody>
</table>
<p></details></p>
</div>
<div id="fitting-the-model" class="section level2">
<h2>Fitting the model</h2>
<p>It is not necessary to run FLASH to convergence before updating <span class="math inline">\(\mu^\star\)</span>. At the extreme, one could do a single FLASH iteration, then update <span class="math inline">\(\mu^\star\)</span>, then run a second FLASH iteration beginning from the updated <span class="math inline">\(\mu^\star\)</span>, and so on.</p>
<p>In the following experiment, I vary the maximum number of iterations between updates of <span class="math inline">\(\mu^\star\)</span> (<code>n_subiter</code>) from 1 to 100 (which is typically enough to achieve convergence). In each case, I greedily add as many factors as possible and then backfit (as in the above example). I track the final objective attained and the time required to fit (in seconds).</p>
<pre class="r"><code>flash_fit &lt;- function(the_data, n_subiter, nonnegative = FALSE,
                      var_type = &quot;zero&quot;, maxiter = 100, tol = .01) {
  fl &lt;- run_one_fit(the_data, f_init = NULL, greedy = TRUE,
                    maxiter = maxiter, n_subiter = n_subiter,
                    nonnegative = nonnegative, var_type = var_type,
                    verbose = FALSE)
  old_obj &lt;- fl$objective
  
  # Keep greedily adding factors until the objective no longer improves:
  diff &lt;- Inf
  while (diff &gt; tol) {
    fl &lt;- run_one_fit(the_data, fl, greedy = TRUE,
                      maxiter = maxiter, n_subiter = n_subiter,
                      nonnegative = nonnegative, var_type = var_type,
                      verbose = FALSE)
    diff &lt;- fl$objective - old_obj
    old_obj &lt;- fl$objective
  }
  
  # Now backfit the whole thing:
  fl &lt;- run_one_fit(the_data, fl, greedy = FALSE, 
                    maxiter = maxiter, n_subiter = n_subiter,
                    nonnegative = nonnegative, var_type = var_type,
                    verbose = FALSE)
  
  return(fl)
}

n_subiters &lt;- c(1, 2, 5, 10, 25, 50, 100)
all_t &lt;- rep(0, length(n_subiters))
all_obj &lt;- rep(0, length(n_subiters))
for (i in 1:length(n_subiters)) {
  t &lt;- system.time(fl &lt;- flash_fit(data, n_subiters[i], 
                                   var_type = &quot;zero&quot;))
  all_t[i] &lt;- t[3]
  all_obj[i] &lt;- fl$objective
}

df &lt;- data.frame(n_subiter = n_subiters, 
                 &quot;time to fit&quot; = all_t, 
                 &quot;final objective&quot; = all_obj)
knitr::kable(df)</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">n_subiter</th>
<th align="right">time.to.fit</th>
<th align="right">final.objective</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">5.699</td>
<td align="right">-16067.89</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">6.404</td>
<td align="right">-16002.42</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">7.432</td>
<td align="right">-16002.74</td>
</tr>
<tr class="even">
<td align="right">10</td>
<td align="right">9.220</td>
<td align="right">-16002.78</td>
</tr>
<tr class="odd">
<td align="right">25</td>
<td align="right">10.206</td>
<td align="right">-16002.79</td>
</tr>
<tr class="even">
<td align="right">50</td>
<td align="right">10.704</td>
<td align="right">-16002.80</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td align="right">11.301</td>
<td align="right">-16002.79</td>
</tr>
</tbody>
</table>
<p>Clearly, capping the number of iterations per FLASH fit reduces overall fitting time. It is possible that too few iterations produces a suboptimal fit (the objective for <code>n_subiter = 1</code> is about 65 less than the other objectives), but this could be an isolated event.</p>
</div>
<div id="nonnegative-loadings" class="section level2">
<h2>Nonnegative loadings</h2>
<p>Since, as I’ve argued in <a href="https://willwerscheid.github.io/MASHvFLASH/MASHvFLASHnn.html">other analyses</a>, putting nonnegative constraints on the loadings helps produce more interpretable factors, I repeat the above experiment with nonnegative “+uniform” priors on the loadings.</p>
<pre class="r"><code>for (i in 1:length(n_subiters)) {
  t &lt;- system.time(fl &lt;- flash_fit(data, n_subiters[i], 
                                   var_type = &quot;zero&quot;, 
                                   nonnegative = TRUE))
  all_t[i] &lt;- t[3]
  all_obj[i] &lt;- fl$objective
}

nonneg_df &lt;- data.frame(n_subiter = n_subiters, 
                 &quot;time to fit (seconds)&quot; = all_t, 
                 &quot;final objective&quot; = all_obj)
knitr::kable(nonneg_df)</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">n_subiter</th>
<th align="right">time.to.fit..seconds.</th>
<th align="right">final.objective</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">16.936</td>
<td align="right">-16158.06</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">18.444</td>
<td align="right">-16154.17</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">21.213</td>
<td align="right">-16149.35</td>
</tr>
<tr class="even">
<td align="right">10</td>
<td align="right">22.375</td>
<td align="right">-16149.35</td>
</tr>
<tr class="odd">
<td align="right">25</td>
<td align="right">18.195</td>
<td align="right">-16148.65</td>
</tr>
<tr class="even">
<td align="right">50</td>
<td align="right">18.752</td>
<td align="right">-16148.65</td>
</tr>
<tr class="odd">
<td align="right">100</td>
<td align="right">18.121</td>
<td align="right">-16148.65</td>
</tr>
</tbody>
</table>
<p>Here, the value of <code>n_subiter</code> doesn’t seem to matter much.</p>
<p>Finally, I refit with <code>n_subiter = 1</code> and plot the resulting factors. Notice, in particular, that the fifth factor is almost exclusively loaded on female reproductive tissues. (Further rounds of greedy addition and backfitting do not yield any additional factors.)</p>
<pre class="r"><code>fl &lt;- flash_fit(data, 1, TRUE)

plot(fl, plot_loadings = TRUE, loading_colors = gtex.colors,
     loading_legend_size = 3, plot_scree = FALSE,
     plot_grid_nrow = 3, plot_grid_ncol = 2)</code></pre>
<p><img src="figure/count_data.Rmd/nonneg2-1.png" width="672" style="display: block; margin: auto;" /></p>
<details> <summary><em>Expand here to see past versions of nonneg2-1.png:</em></summary>
<table style="border-collapse:separate; border-spacing:5px;">
<thead>
<tr>
<th style="text-align:left;">
Version
</th>
<th style="text-align:left;">
Author
</th>
<th style="text-align:left;">
Date
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<a href="https://github.com/willwerscheid/FLASHvestigations/blob/410eb80ebb5d5f78bd8705794330bc8a11a0c7f8/docs/figure/count_data.Rmd/nonneg2-1.png" target="_blank">410eb80</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-22
</td>
</tr>
<tr>
<td style="text-align:left;">
<a href="https://github.com/willwerscheid/FLASHvestigations/blob/8b731598d9b702cdb6b353a34e1db6d688dca2ae/docs/figure/count_data.Rmd/nonneg2-1.png" target="_blank">8b73159</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-21
</td>
</tr>
</tbody>
</table>
<p></details></p>
</div>
<div id="a-streamlined-approach" class="section level2">
<h2>A streamlined approach</h2>
<p>It might be worth it to try to streamline the approach by getting a good initialization point, running FLASH a single time to update <span class="math inline">\(\mu^\star\)</span>, and then forgetting about the original data entirely.</p>
<p>I obtain an initialization point by running nonnegative FLASH on the data (recall that <span class="math inline">\(\mu^\star\)</span> must be strictly positive).</p>
<pre class="r"><code>t_init &lt;- system.time(
  fl &lt;- suppressWarnings(
    flash(data, var_type = &quot;by_row&quot;, ebnm_fn = &quot;ebnm_ash&quot;, 
          ebnm_param = list(mixcompdist = &quot;+uniform&quot;),
          verbose = FALSE)
  )
)
mu &lt;- fl$fitted_values
round(t_init[3], digits = 2)
#&gt; elapsed 
#&gt;    5.57</code></pre>
<p>Now I run FLASH on the pseudo-data and update <span class="math inline">\(\mu^\star\)</span>:</p>
<pre class="r"><code>pseudodata &lt;- set_pseudodata(data, mu)
t_update &lt;- system.time(
  fl &lt;- suppressWarnings(
    flash(pseudodata, var_type = &quot;zero&quot;, backfit = TRUE, 
          verbose = FALSE)
  )
)
mu &lt;- exp(fl$fitted_values)
round(t_update[3], digits = 2)
#&gt; elapsed 
#&gt;     3.4</code></pre>
<pre class="r"><code>pseudodata &lt;- set_pseudodata(data, mu)
t_final &lt;- system.time(
  fl &lt;- suppressWarnings(
    flash(pseudodata, var_type = &quot;zero&quot;, backfit = TRUE, 
          verbose = FALSE)
  )
)
round(t_final[3], digits = 2)
#&gt; elapsed 
#&gt;    2.09</code></pre>
<p>As expected, the objective is worse than the the objective attained using the more involved approach above (it is about 300 lower):</p>
<pre class="r"><code>calc_obj(fl, data, mu)
#&gt; [1] -16302.38</code></pre>
<p>The loadings are also fairly strange:</p>
<pre class="r"><code>plot(fl, plot_loadings = TRUE, loading_colors = gtex.colors,
     loading_legend_size = 3, plot_scree = FALSE)</code></pre>
<p><img src="figure/count_data.Rmd/two_iter5b-1.png" width="672" style="display: block; margin: auto;" /></p>
<details> <summary><em>Expand here to see past versions of two_iter5b-1.png:</em></summary>
<table style="border-collapse:separate; border-spacing:5px;">
<thead>
<tr>
<th style="text-align:left;">
Version
</th>
<th style="text-align:left;">
Author
</th>
<th style="text-align:left;">
Date
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<a href="https://github.com/willwerscheid/FLASHvestigations/blob/410eb80ebb5d5f78bd8705794330bc8a11a0c7f8/docs/figure/count_data.Rmd/two_iter5b-1.png" target="_blank">410eb80</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-22
</td>
</tr>
<tr>
<td style="text-align:left;">
<a href="https://github.com/willwerscheid/FLASHvestigations/blob/8b731598d9b702cdb6b353a34e1db6d688dca2ae/docs/figure/count_data.Rmd/two_iter5b-1.png" target="_blank">8b73159</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-21
</td>
</tr>
</tbody>
</table>
<p></details></p>
<p>Further, this simpler approach is slower than the above approach, especially for small values of <code>n_subiter</code>:</p>
<pre class="r"><code>round(t_init[3] + t_update[3] + t_final[3], digits = 2)
#&gt; elapsed 
#&gt;   11.06</code></pre>
</div>
<div id="accounting-for-overdispersion" class="section level2">
<h2>Accounting for overdispersion</h2>
<p>In the above examples, I used <code>var_type = &quot;zero&quot;</code> (I did so because convergence is typically better behaved). Often, however, it will be more appropriate to set <code>var_type = &quot;constant&quot;</code>. In the example under consideration, a “constant” variance structure yields more structure, more interpretable factors (note, in particular, the sex-specific fourth loading), and a much better objective:</p>
<pre class="r"><code>fl &lt;- flash_fit(data, 1, var_type = &quot;constant&quot;)
fl$objective
#&gt; [1] 23905.85
plot(fl, plot_loadings = TRUE, loading_colors = gtex.colors,
     loading_legend_size = 3, plot_scree = FALSE)</code></pre>
<p><img src="figure/count_data.Rmd/constant-1.png" width="672" style="display: block; margin: auto;" /></p>
<details> <summary><em>Expand here to see past versions of constant-1.png:</em></summary>
<table style="border-collapse:separate; border-spacing:5px;">
<thead>
<tr>
<th style="text-align:left;">
Version
</th>
<th style="text-align:left;">
Author
</th>
<th style="text-align:left;">
Date
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<a href="https://github.com/willwerscheid/FLASHvestigations/blob/410eb80ebb5d5f78bd8705794330bc8a11a0c7f8/docs/figure/count_data.Rmd/constant-1.png" target="_blank">410eb80</a>
</td>
<td style="text-align:left;">
Jason Willwerscheid
</td>
<td style="text-align:left;">
2018-09-22
</td>
</tr>
</tbody>
</table>
<p></details></p>
</div>
<div id="session-information" class="section level2">
<h2>Session information</h2>
<pre class="r"><code>sessionInfo()
#&gt; R version 3.4.3 (2017-11-30)
#&gt; Platform: x86_64-apple-darwin15.6.0 (64-bit)
#&gt; Running under: macOS High Sierra 10.13.6
#&gt; 
#&gt; Matrix products: default
#&gt; BLAS: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRblas.0.dylib
#&gt; LAPACK: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib
#&gt; 
#&gt; locale:
#&gt; [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
#&gt; 
#&gt; attached base packages:
#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     
#&gt; 
#&gt; other attached packages:
#&gt; [1] ebnm_0.1-15  flashr_0.6-2
#&gt; 
#&gt; loaded via a namespace (and not attached):
#&gt;  [1] Rcpp_0.12.18        highr_0.6           pillar_1.2.1       
#&gt;  [4] plyr_1.8.4          compiler_3.4.3      git2r_0.21.0       
#&gt;  [7] workflowr_1.0.1     R.methodsS3_1.7.1   R.utils_2.6.0      
#&gt; [10] iterators_1.0.9     tools_3.4.3         testthat_2.0.0     
#&gt; [13] digest_0.6.15       tibble_1.4.2        evaluate_0.10.1    
#&gt; [16] memoise_1.1.0       gtable_0.2.0        lattice_0.20-35    
#&gt; [19] rlang_0.2.0         Matrix_1.2-12       foreach_1.4.4      
#&gt; [22] commonmark_1.4      yaml_2.1.17         parallel_3.4.3     
#&gt; [25] withr_2.1.1.9000    stringr_1.3.0       roxygen2_6.0.1.9000
#&gt; [28] xml2_1.2.0          knitr_1.20          REBayes_1.2        
#&gt; [31] devtools_1.13.4     rprojroot_1.3-2     grid_3.4.3         
#&gt; [34] R6_2.2.2            rmarkdown_1.8       reshape2_1.4.3     
#&gt; [37] ggplot2_2.2.1       ashr_2.2-13         magrittr_1.5       
#&gt; [40] whisker_0.3-2       backports_1.1.2     scales_0.5.0       
#&gt; [43] codetools_0.2-15    htmltools_0.3.6     MASS_7.3-48        
#&gt; [46] assertthat_0.2.0    softImpute_1.4      colorspace_1.3-2   
#&gt; [49] labeling_0.3        stringi_1.1.6       Rmosek_7.1.3       
#&gt; [52] lazyeval_0.2.1      doParallel_1.0.11   pscl_1.5.2         
#&gt; [55] munsell_0.4.3       truncnorm_1.0-8     SQUAREM_2017.10-1  
#&gt; [58] R.oo_1.21.0</code></pre>
</div>

<!-- Adjust MathJax settings so that all math formulae are shown using
TeX fonts only; see
http://docs.mathjax.org/en/latest/configuration.html.  This will make
the presentation more consistent at the cost of the webpage sometimes
taking slightly longer to load. Note that this only works because the
footer is added to webpages before the MathJax javascript. -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>

<hr>
<p>
  This reproducible <a href="http://rmarkdown.rstudio.com">R Markdown</a>
  analysis was created with
  <a href="https://github.com/jdblischak/workflowr">workflowr</a> 1.0.1
</p>
<hr>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
